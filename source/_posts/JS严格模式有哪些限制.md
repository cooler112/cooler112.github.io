---
title: JS严格模式有哪些限制
date: 2021-01-09 18:16:31
tags: js
categories: 前端开发
---

严格模式的主要目标之一，是显式捕获那些容易产生但在运行时并不明显的编码错误。严格模式中添加了如下的新运行时错误：

- 给未声明的标识符赋值。在旧版 JavaScript 中，对输错的变量名称进行赋值，会导致在全局对象上创建属性。
- 给只读的自有或继承属性赋值。在旧版 JavaScript 中，这种操作会静默地不生效。
- 尝试在不可扩展的对象上创建属性。这样的对象在 ES5 之前并不存在，但为了保持一致性，在 ES5 中的严格模式之外执行此操作时，也将会静默地不生效。
- 将 delete 运算符应用于不可删除的属性。在旧版 JavaScript 中，这时的 delete 会返回 false。
- 将 delete 运算符应用于变量引用会产生语法错误。在旧版 JavaScript 中，对于显式声明的变量，delete 会返回 false。如果变量引用来自与 with 语句相配合的对象，或者属于全局对象的属性，那么它在旧版 JavaScript 中将被删除。

严格模式还会移除或修改那些可能使程序更混乱、更难优化或更不安全的特性：

- 禁用 with 语句。with 语句提供了一种变量引用的动态作用域形式，这种形式可能会造成困扰，并且不利于各实现中的优化。
- eval 函数不能动态添加新绑定到当前作用域。
- eval 和 arguments 不能用作变量名或参数名。
- 函数的 arguments 对象不与其形参相关联。作为替代，严格模式下的 arguments 对象是一个数组式（array-like）的对象，其元素是传递给函数的参数值的快照。修改其元素不会修改相应形参的值，反之亦然。
- 严格模式下，函数的 arguments 对象没有 callee 属性。将这样的 arguments 对象传递给其他代码时，不会再隐式转移出对其上函数的调用能力[81](https://github.com/doodlewind/jshistory-cn/blob/master/notes.md#81)。
- 严格模式下，不允许实现在函数的 arguments 对象上提供 caller 属性。 caller 属性是 ES3 的一个非标准但已广泛实现的扩展，它允许遍历函数的调用堆栈，获取到所有的调用者函数。
- 严格模式下，调用函数时如果没有提供 this 值，全局对象对其就不可见。